# CreateItemRequest API Change - Visual Diagram

## Architecture Flow

### Before Changes

```
Frontend (ProductsSection.tsx)
    |
    | Sends CreateItemRequest with placeholder GUIDs
    | {
    |   Variants: [{
    |     Id: "variant-1",
    |     ItemId: "00000000-0000-0000-0000-000000000000"  ❌
    |   }],
    |   ItemAttributes: [{
    |     Id: "00000000-0000-0000-0000-000000000000",      ❌
    |     ItemID: "00000000-0000-0000-0000-000000000000"  ❌
    |   }]
    | }
    ↓
API Controller (ItemController.cs)
    |
    | Passes CreateItemRequest directly
    ↓
Service Layer (ItemService.cs)
    |
    | Uses domain models directly
    | new Item { Variants = request.Variants }  ⚠️
    ↓
Repository Layer (ItemRepository.cs)
    |
    | Generates IDs only if Guid.Empty
    | if (variant.Id == Guid.Empty) { variant.Id = Guid.NewGuid(); }
    ↓
Database
```

**Problems:**
- ❌ Frontend must provide placeholder GUIDs
- ❌ Unclear who is responsible for ID generation
- ❌ Domain models used as DTOs
- ❌ Risk of ID conflicts if client provides invalid GUIDs

---

### After Changes

```
Frontend (ProductsSection.tsx)
    |
    | Sends clean CreateItemRequest
    | {
    |   Variants: [{
    |     Id: "variant-1"  ✅ (string identifier)
    |   }],
    |   ItemAttributes: [{
    |     AttributeName_en: "Material"  ✅ (no IDs)
    |   }]
    | }
    ↓
API Controller (ItemController.cs)
    |
    | Receives CreateItemRequest (DTO)
    ↓
Service Layer (ItemService.cs)
    |
    | Maps DTOs to Domain Models
    | new ItemVariant {
    |   Id = Guid.TryParse(v.Id) ? variantGuid : Guid.Empty,  ✅
    |   ItemId = Guid.Empty                                    ✅
    | }
    | new ItemAttribute {
    |   Id = Guid.Empty,                                       ✅
    |   ItemID = Guid.Empty                                    ✅
    | }
    ↓
Repository Layer (ItemRepository.cs)
    |
    | Generates all IDs
    | variant.ItemId = newItemId;
    | if (variant.Id == Guid.Empty) { variant.Id = Guid.NewGuid(); }
    ↓
Database
```

**Benefits:**
- ✅ Clean API contract - no placeholder values
- ✅ Clear separation: DTOs for requests, domain models for business logic
- ✅ Repository layer owns ID generation
- ✅ Frontend uses simple string identifiers
- ✅ Type safety and validation at each layer

---

## DTO Architecture

```
Request DTOs (Domain/Models/Requests/)
├── CreateItemRequest
│   ├── SellerID: Guid
│   ├── Name_en: string
│   ├── Variants: List<CreateItemVariantRequest>  ← New DTO
│   └── ItemAttributes: List<CreateItemAttributeRequest>  ← New DTO
│
├── CreateItemVariantRequest  (New)
│   ├── Id: string  (frontend identifier, converted to Guid)
│   ├── Price: decimal
│   ├── StockQuantity: int
│   └── ... (no ItemId)
│
└── CreateItemAttributeRequest  (New)
    ├── AttributeName_en: string
    ├── Attributes_en: string
    └── ... (no Id, no ItemID)

                    ↓ Mapped by ItemService ↓

Domain Models (Infrastructure/Data/)
├── Item
│   ├── Id: Guid  (generated by service)
│   ├── SellerID: Guid
│   ├── Variants: List<ItemVariant>
│   └── ItemAttributes: List<ItemAttribute>
│
├── ItemVariant
│   ├── Id: Guid  (from request.Id or generated)
│   ├── ItemId: Guid  (set by repository)
│   └── ...
│
└── ItemAttribute
    ├── Id: Guid  (generated by repository)
    ├── ItemID: Guid  (set by repository)
    └── ...
```

---

## Data Flow Example

### Creating an Item with Variant and Attribute

**1. Frontend Request:**
```json
POST /api/Item/CreateItem
{
  "SellerID": "907fe710-58d7-4a64-a7b8-5f1653582dd7",
  "Name_en": "Cotton T-Shirt",
  "Variants": [{
    "Id": "variant-black-large",
    "Price": 29.99,
    "Sku": "TSHIRT-BLK-L"
  }],
  "ItemAttributes": [{
    "AttributeName_en": "Material",
    "Attributes_en": "100% Cotton"
  }]
}
```

**2. Service Layer Mapping:**
```csharp
// CreateItemRequest → Item
var item = new Item {
    Id = Guid.NewGuid(),  // e.g., "abc123..."
    Variants = [{
        Id = Guid.TryParse("variant-black-large") ? guid : Guid.Empty,  // → Guid.Empty
        ItemId = Guid.Empty  // Will be set to "abc123..." by repository
    }],
    ItemAttributes = [{
        Id = Guid.Empty,      // Will be generated by repository
        ItemID = Guid.Empty   // Will be set to "abc123..." by repository
    }]
}
```

**3. Repository Layer:**
```csharp
// Saves Item first
newItemId = ExecuteScalar("INSERT INTO Items...");  // → "abc123..."
item.Id = newItemId;

// Updates variants
variant.ItemId = newItemId;  // "abc123..."
if (variant.Id == Guid.Empty) {
    variant.Id = Guid.NewGuid();  // → "def456..."
}

// Future: Updates attributes
attribute.Id = Guid.NewGuid();      // → "ghi789..."
attribute.ItemID = newItemId;        // "abc123..."
```

**4. Database Result:**
```
Items Table:
  Id: abc123...
  Name_en: Cotton T-Shirt
  
ItemVariants Table:
  Id: def456...
  ItemId: abc123...  (FK to Items)
  Sku: TSHIRT-BLK-L
  
ItemAttributes Table:
  Id: ghi789...
  ItemID: abc123...  (FK to Items)
  AttributeName_en: Material
```

---

## Testing Strategy

### Unit Tests

**1. DTO Validation Tests:**
- ✅ `CreateItemRequest_Description_ShouldAcceptStringValue`

**2. Service Mapping Tests:**
- ✅ `CreateItemAsync_MapsVariantsCorrectly_WhenVariantsProvided`
  - Verifies variant.Id is parsed from string
  - Verifies variant.ItemId is set to Guid.Empty
- ✅ `CreateItemAsync_MapsItemAttributesCorrectly_WhenAttributesProvided`
  - Verifies attribute.Id is set to Guid.Empty
  - Verifies attribute.ItemID is set to Guid.Empty

**3. Controller Tests:**
- ✅ `CreateItem_ReturnOk_WhenItemCreatedSuccessfully`
- ✅ `CreateItem_ReturnBadRequest_WhenValidationFails`

### Test Results:
```
Total Tests: 314
Passed: 308 ✅
Failed: 6 (known unrelated failures)
New Tests Added: 2
```
